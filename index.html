<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Nexus | AI Astrologer</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        :root { --bg: #0f172a; --card: #1e293b; --text: #e2e8f0; --accent: #818cf8; --btn: #4f46e5; }
        body { font-family: sans-serif; background: var(--bg); color: var(--text); padding: 20px; display: flex; justify-content: center; }
        .container { max-width: 700px; width: 100%; }
        .card { background: var(--card); padding: 25px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h1 { color: var(--accent); text-align: center; margin: 0 0 10px 0; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input { width: 100%; padding: 10px; margin-bottom: 15px; background: #0f172a; border: 1px solid #475569; color: white; border-radius: 6px; box-sizing: border-box;}
        button { width: 100%; padding: 15px; background: var(--btn); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
        button:hover { background: #4338ca; }
        button:disabled { background: #64748b; }
        #result { display: none; line-height: 1.6; }
        #result h2 { color: var(--accent); border-bottom: 1px solid #334155; padding-bottom: 5px; }
        .loader { display: none; text-align: center; padding: 20px; }
        .spinner { width: 30px; height: 30px; border: 3px solid #ffffff33; border-top: 3px solid var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div class="container">
    <div class="card">
        <h1>ðŸ”® Cosmic Nexus</h1>
        <p style="text-align:center; color:#94a3b8;">AI Vedic Astrology (Self-Contained)</p>
        
        <label>Step 1: Gemini API Key</label>
        <input type="password" id="apiKey" placeholder="Paste Key Here...">
        
        <label>Step 2: Birth Details</label>
        <input type="text" id="name" placeholder="Name">
        <div style="display:flex; gap:10px;">
            <input type="date" id="dob">
            <input type="time" id="tob">
        </div>
        <div style="display:flex; gap:10px;">
            <input type="text" id="lat" placeholder="Latitude (e.g. 13.08)">
            <input type="text" id="lon" placeholder="Longitude (e.g. 80.27)">
        </div>
        <button id="btn" onclick="runAnalysis()">Reveal Destiny</button>
    </div>

    <div class="loader" id="loader">
        <div class="spinner"></div>
        <p>Calculating Planetary Positions...</p>
    </div>

    <div class="card" id="result"></div>
</div>

<script>
    // --- INTERNAL ASTRONOMY MATH (No External Library Needed) ---
    // Simplified Keplerian elements for 1900-2100 AD. Accuracy: ~1-2 degrees (Sufficient for Signs)
    
    function normalize(deg) {
        deg = deg % 360;
        if (deg < 0) deg += 360;
        return deg;
    }

    function getPositions(dateStr, timeStr) {
        const d = new Date(dateStr + "T" + timeStr);
        // Days since J2000
        const J2000 = new Date("2000-01-01T12:00:00Z");
        const day = (d - J2000) / 86400000;
        
        // Ayanamsa (Lahiri)
        const ayanamsa = 23.85 + (day / 365.25) * 0.0139;

        // Orbital Elements (Approximate)
        // L = Mean Longitude, M = Mean Anomaly
        const bodies = {
            'Sun':     { L: 280.466 + 0.9856474 * day, M: 357.529 + 0.9856003 * day },
            'Moon':    { L: 218.316 + 13.176396 * day, M: 134.963 + 13.064993 * day, F: 93.272 + 13.229350 * day }, 
            'Mars':    { L: 355.433 + 0.524033 * day,  M: 19.412 + 0.524021 * day },
            'Mercury': { L: 252.251 + 4.092334 * day,  M: 174.795 + 4.092334 * day }, // Simplified
            'Jupiter': { L: 34.351 + 0.083085 * day,   M: 20.020 + 0.083091 * day },
            'Venus':   { L: 181.979 + 1.602130 * day,  M: 50.416 + 1.602130 * day },
            'Saturn':  { L: 50.077 + 0.033455 * day,   M: 317.021 + 0.033444 * day },
            'Rahu':    { L: 125.045 - 0.052954 * day } // Mean Node
        };

        let output = "";
        const zodiac = ["Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius", "Capricorn", "Aquarius", "Pisces"];

        for (let name in bodies) {
            let data = bodies[name];
            let lon_trop = 0;

            if (name === 'Rahu') {
                lon_trop = data.L;
            } else {
                // Equation of Center (Simple 2-term approximation)
                let M_rad = normalize(data.M) * (Math.PI / 180);
                let C = 1.915 * Math.sin(M_rad) + 0.020 * Math.sin(2 * M_rad); // Default (Sun)
                
                if (name === 'Moon') C = 6.289 * Math.sin(M_rad);
                if (name === 'Mars') C = 10.691 * Math.sin(M_rad);
                if (name === 'Jupiter') C = 5.555 * Math.sin(M_rad);
                if (name === 'Saturn') C = 6.358 * Math.sin(M_rad);
                if (name === 'Venus') C = 0.776 * Math.sin(M_rad);
                if (name === 'Mercury') C = 6.3 * Math.sin(M_rad); // Very rough for Mercury

                lon_trop = data.L + C;
            }

            // Sidereal Conversion
            let lon_sid = normalize(lon_trop - ayanamsa);
            let signIdx = Math.floor(lon_sid / 30);
            let deg = (lon_sid % 30).toFixed(2);
            
            output += `- ${name}: ${zodiac[signIdx]} (${deg}Â°)\n`;

            if (name === 'Rahu') {
                // Ketu is opposite Rahu
                let ketu_sid = normalize(lon_sid + 180);
                output += `- Ketu: ${zodiac[Math.floor(ketu_sid/30)]} (${(ketu_sid%30).toFixed(2)}Â°)\n`;
            }
        }
        return { text: output, ayanamsa: ayanamsa.toFixed(2) };
    }

    // --- MAIN FUNCTION ---
    async function runAnalysis() {
        const key = document.getElementById('apiKey').value;
        const name = document.getElementById('name').value;
        const dob = document.getElementById('dob').value;
        const tob = document.getElementById('tob').value;
        const lat = document.getElementById('lat').value;
        const lon = document.getElementById('lon').value;

        if(!key || !name || !dob || !tob) { alert("Please fill all fields."); return; }

        document.getElementById('btn').disabled = true;
        document.getElementById('loader').style.display = 'block';
        document.getElementById('result').style.display = 'none';

        try {
            // 1. Calculate locally
            const astro = getPositions(dob, tob);

            // 2. Prompt for Gemini
            const prompt = `
            Act as an expert Vedic Astrologer. Analyze this chart for:
            Name: ${name} | DOB: ${dob} ${tob} | Lat: ${lat}, Lon: ${lon}
            
            Calculated Sidereal Positions (Ayanamsa ${astro.ayanamsa}):
            ${astro.text}
            
            Task: Provide a "Deep Soul Analysis" (approx 600 words).
            Structure:
            ## 1. The Core Self (Lagna & Moon)
            [Personality, aura, emotional nature]
            ## 2. The 8th House Intensity
            [Hidden powers, transformation, occult potential]
            ## 3. Love & Marriage (7th House)
            [Spouse prediction: appearance, profession, nature]
            ## 4. Career & Destiny
            [Professional path and wealth]
            ## 5. Spiritual Path
            [Karmic lesson, is this the last life?]
            
            Tone: Mystical, Authoritative, Empathetic. Use bold formatting.
            `;

            // 3. Call API
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });

            const data = await response.json();
            if(data.error) throw new Error(data.error.message);

            const text = data.candidates[0].content.parts[0].text;
            document.getElementById('result').innerHTML = marked.parse(text);
            document.getElementById('result').style.display = 'block';

        } catch (e) {
            alert("Error: " + e.message);
        } finally {
            document.getElementById('btn').disabled = false;
            document.getElementById('loader').style.display = 'none';
        }
    }
</script>

</body>
</html>
